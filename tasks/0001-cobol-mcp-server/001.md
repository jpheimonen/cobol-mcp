# 001: COBOL program skeleton with JSON parsing and main loop

## Context

This is the foundational step. Everything in subsequent steps — lifecycle handling, request routing, tool implementations — depends on having a working COBOL program structure with the ability to read from stdin, parse JSON-RPC fields out of incoming messages, and generate JSON responses on stdout. Without this skeleton, nothing else can be built.

The JSON handling is the hardest part of the entire project. COBOL has no JSON libraries, so parsing and generation must be implemented from scratch using native string operations. This step tackles that challenge head-on so that steps 002 and 003 can focus on protocol logic and tool behavior rather than string wrangling.

## Related Code

This is a greenfield project — there is no existing code in the repository to reference or extend.

## Reuse Opportunities

None — empty repo. Everything is new.

## Deliverables

### Main COBOL source file at `src/mcp-server.cob`

A GnuCOBOL free-format source file containing the complete program skeleton. It must include:

**Program structure (all four COBOL divisions):**
- IDENTIFICATION DIVISION with program name and descriptive comments
- ENVIRONMENT DIVISION (may be minimal for a stdio-based program)
- DATA DIVISION with WORKING-STORAGE SECTION containing all variable definitions
- PROCEDURE DIVISION with the main logic

**Working storage variables for:**
- An input line buffer, generously sized (at least 4000 characters) to hold incoming JSON-RPC messages
- An output line buffer of similar size for constructing JSON responses
- Parsed field storage: variables to hold the extracted `jsonrpc` version string, `method` name, request `id` (as a string, since JSON-RPC IDs can be strings or numbers), and a flag indicating whether an `id` was present (to distinguish requests from notifications)
- Parsed params storage: variables to hold extracted values from the `params` object — specifically `params.name` (tool name for tools/call) and argument values that the tools will need (these can be placeholder variables that step 003 will populate)
- Temporary/working variables for string scanning: position counters, length trackers, character inspection variables
- A server-running flag to control the main loop
- An EOF detection flag

**Main event loop:**
- Continuously read one line at a time from stdin
- On end-of-file, exit the loop cleanly and terminate the program with a zero exit code
- For each line read, invoke the JSON parsing logic to extract fields
- After parsing, the skeleton should have a dispatch point (an EVALUATE or series of IF statements) where the method name is checked — but in this step, the dispatch can simply fall through to an "unrecognized" response. Steps 002 and 003 will fill in the actual handlers.
- After dispatching, if a response was generated, write the output buffer to stdout as a single line

**JSON field extraction (parsing):**
- A procedure/paragraph that takes the input buffer and extracts the value of a named JSON key from it
- Must handle: string values (quoted), numeric values (unquoted), and be able to locate keys at the top level of the JSON object and within nested objects (at least one level deep for `params`)
- The parser does not need to handle arrays, deeply nested structures, or edge cases beyond what MCP JSON-RPC messages actually contain
- Must handle the `id` field which can be either a number or a string in JSON-RPC
- Should set a flag or indicator if parsing fails (e.g., no `method` field found) so the caller can return a parse error

**JSON response generation:**
- A procedure/paragraph that constructs a JSON-RPC response line in the output buffer using COBOL's STRING verb
- Must support building: a success response (with `jsonrpc`, `id`, and a `result` value), an error response (with `jsonrpc`, `id`, `error.code`, and `error.message`), and a notification acknowledgment (no response generated)
- The request `id` from the incoming message must be echoed back in the response
- All output must be a single line with no embedded newlines
- Quote characters within the JSON must be properly handled (COBOL does not use backslash escaping natively, so the double-quote character needs to be inserted via its literal or hex representation)

## Acceptance Criteria

- [ ] `src/mcp-server.cob` exists and is written in GnuCOBOL free-format (not fixed-format column layout)
- [ ] The file contains all four COBOL divisions: IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE
- [ ] Working storage defines an input buffer of at least 4000 characters
- [ ] Working storage defines variables for parsed JSON fields: method, id, id-present flag, and params-level fields
- [ ] The PROCEDURE DIVISION contains a main loop that reads from stdin line by line
- [ ] The main loop terminates cleanly when end-of-file is detected on stdin
- [ ] A JSON field extraction paragraph/section exists that can locate a key in the input buffer and extract its value
- [ ] A JSON response generation paragraph/section exists that builds a JSON-RPC response string in the output buffer using STRING operations
- [ ] The response generator can produce both success responses (with result) and error responses (with error code and message)
- [ ] The output is written to stdout as a single line per response
- [ ] The program includes a dispatch point where the extracted method name would be matched — even if all branches currently fall through to a default/placeholder
- [ ] The file uses `>>SOURCE FORMAT FREE` or equivalent GnuCOBOL free-format directive
