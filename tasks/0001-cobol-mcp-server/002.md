# 002: MCP lifecycle and request routing

## Context

Step 001 created the COBOL program skeleton with JSON parsing, response generation, and a main loop with a placeholder dispatch point. This step fills in that dispatch point with the actual MCP protocol lifecycle handling and request routing.

The MCP protocol requires a specific initialization handshake before normal operations can begin. The server must respond to the `initialize` request with its identity, protocol version, and declared capabilities. It must silently absorb the `initialized` notification. It must handle `ping` at any time. And it must route `tools/list` and `tools/call` to the right place (though the actual tool logic comes in step 003 — this step just sets up the routing and stubs).

This step also adds proper error responses for unknown methods and parse failures, completing the server's ability to handle any message thrown at it without crashing.

## Related Code

- `src/mcp-server.cob` — The skeleton created in step 001. This step modifies the dispatch point (EVALUATE/IF block) in the PROCEDURE DIVISION and adds new paragraphs/sections for each method handler. It also adds any new working storage variables needed for protocol state (e.g., whether initialization has completed).

## Reuse Opportunities

- The JSON response generation paragraph from step 001 should be reused for all responses built in this step. Each method handler prepares the response content and then calls the existing response builder.
- The JSON field extraction paragraph from step 001 is used to pull the `method` and `id` out of incoming messages for routing.

## Deliverables

### Modifications to `src/mcp-server.cob`

**Protocol state tracking in working storage:**
- Add a flag or variable to track whether the server has completed initialization (received `initialize` and sent the response). The server should still handle messages before initialization completes — the MCP spec says the server SHOULD NOT send requests other than pings before receiving `initialized`, but the server should not reject incoming messages pre-initialization.

**Initialize handler:**
- When the method is `initialize`, the server responds with a JSON-RPC success response containing:
  - `protocolVersion` set to `2025-11-25`
  - `serverInfo` with `name` set to `cobol-mcp-server` and a `version` string
  - `capabilities` declaring `tools` support (just the tools capability object — no resources, no prompts, no logging, no completions)
- The response must be valid JSON with the request `id` echoed back
- The initialize handler should set the internal initialization-complete flag

**Initialized notification handler:**
- When the method is `notifications/initialized`, the server produces no output at all. This is a notification (no `id`), so no response is sent. The server silently acknowledges it and continues the main loop.

**Ping handler:**
- When the method is `ping`, the server responds with a JSON-RPC success response containing an empty result object, echoing back the request `id`.

**Tools/list routing stub:**
- When the method is `tools/list`, route to a paragraph/section that will be fleshed out in step 003. For now, it can return an empty tools array in the result, or a placeholder response. The important thing is the routing exists.

**Tools/call routing stub:**
- When the method is `tools/call`, route to a paragraph/section that will be fleshed out in step 003. For now, it can return a placeholder tool result. The important thing is the routing exists and that the tool name is extracted from `params.name`.

**Unknown method error handling:**
- When the method does not match any known method string, respond with a JSON-RPC error response using error code -32601 and a message indicating the method was not found. The request `id` must be echoed back.

**Parse error handling:**
- When the JSON parsing step fails to extract a `method` field from the input, respond with a JSON-RPC error response using error code -32700 and a parse error message. If the `id` could be extracted, include it; otherwise the error response may omit it or use null.

## Acceptance Criteria

- [x] The dispatch point in the main loop routes to distinct handler paragraphs/sections based on the extracted method name
- [x] Sending an `initialize` message produces a response containing `protocolVersion` with value `2025-11-25`
- [x] The initialize response contains `serverInfo` with `name` set to `cobol-mcp-server`
- [x] The initialize response contains a `capabilities` object that includes `tools`
- [x] The initialize response echoes back the request `id` from the incoming message
- [x] Sending a `notifications/initialized` message produces no output on stdout
- [x] Sending a `ping` message produces a response with an empty result object and the matching request `id`
- [x] Sending a message with an unknown method produces a JSON-RPC error response with code -32601
- [x] A malformed message that cannot be parsed produces a JSON-RPC error response with code -32700
- [x] A routing path exists for `tools/list` (even if it returns a placeholder response for now)
- [x] A routing path exists for `tools/call` (even if it returns a placeholder response for now)
- [x] The `tools/call` routing extracts the tool name from `params.name` before dispatching
- [x] All responses include `"jsonrpc":"2.0"` (or equivalent with spacing)
- [x] The server continues running and accepting input after handling any of these messages (does not exit after one request)
